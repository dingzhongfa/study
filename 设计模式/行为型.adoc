= 十一种行为型设计模式

=== 策略模式

.组成
环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。
抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。
具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。

.个人见解
与桥接模式没啥区别，硬要说的化，比方说A调用B，桥接里A有抽象父类，而策略没有

=== 模板方法模式
.模式中的角色
* 抽象类（AbstractClass）：实现了模板方法，定义了算法的骨架。
* 具体类（ConcreteClass)：实现抽象类中的抽象方法，已完成完整的算法。

.个人见解
抽象类中定义流程方法方法，流程中包含各个抽象方法，留给子类实现。

=== 观察者模式
.角色：
* 抽象被观察者角色：把所有对观察者对象的引用保存在一个集合中，每个被观察者角色都可以有任意数量的观察者。被观察者提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
抽象观察者角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。
* 具体被观察者角色：在被观察者内部状态改变时，给所有登记过的观察者发出通知。具体被观察者角色通常用一个子类实现。
* 具体观察者角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。

.个人见解
当中与组合模式的席位区别，可以细细思量，个人认为两者用的一个套路，但是主要有两点不同，1、目标效果不同，2、角色之间的关系不同。

=== 迭代子模式

.个人见解
即集合的iterator,定一个内部类来进行迭代遍历

=== 责任链模式

.个人见解
处理角色内置一个同类型的全局变量，对于一个方法做处理并决定是否由下一个处理类继续执行。其实与装饰者和静态代理一样，无非是朝不同的方向使用

=== 命令模式

====
.角色
* Command：定义命令的接口，声明执行的方法。
* ConcreteCommand：命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
* Receiver： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
* Invoker： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
* Client： 创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。

.个人见解
主要是将命令抽象成一个个对象，由一个Invoker（控制类）统一管理，command对象为由一个Invoker内的全局变量，同时command内置一个Receiver全局变量。主要是为了解耦。
====

=== 备忘录模式

* 发起人角色
　　发起人角色有如下责任：
. 创建一个含有当前的内部状态的备忘录对象。
. 使用备忘录对象存储其内部状态。
* 负责人角色
　　负责人角色有如下责任：
. 负责保存备忘录对象。
. 不检查备忘录对象的内容。

.个人见解
负责人是一个抽象出来的类。


=== 状态模式

====
.角色：
* 环境类：内置一个状态对象
* 状态类：多个状态类在各自方法内设置环境类的角色切换，环境类调用时以this传自身对象
====

=== 访问者模式

.优点
* 符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。
* 扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。（元素不易扩展）

.通俗易懂的说法
A调B，B回调A，以形参传值

=== 中介者模式

.通俗易懂的说法
创建中介者对象，当各个对象之间有相互影响时，通过中介者对象处理。
=== 解释器模式

计算器的实现可以参考 https://www.jianshu.com/p/c138a1d2be5e
= 五种创建型设计模式

创建对象的五种设计模式

=== 工厂方法模式

====
场景：许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置; 选择生成哪个子对象实例; 或在生成你需要的对象之前必须先生成一些辅助功能的对象。 在这些情况,新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。
----
问题：你如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程呢？

* 解决方案： 建立一个工厂来创建对象
----
====

=== 抽象工厂模式

====
抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。比如宝马320系列使用空调型号A和发动机型号A，而宝马230系列使用空调型号B和发动机型号B，那么使用抽象工厂模式，在为320系列生产相关配件时，就无需制定配件的型号，它会自动根据车型生产对应的配件型号A。
====

TIP: 没有多大花头，无非是多了一级子类。

NOTE: 当子类级数增多时，工厂模式该如何做改变，相信答案会很丰富多彩

=== 单例模式

====
场景：单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。

java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例
====

单例模式有以下特点：

* 单例类只能有一个实例。
* 单例类必须自己创建自己的唯一实例。
* 单例类必须给所有其他对象提供这一实例。


=== 建造者模式

====
定义：将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

实用范围

1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。

2、当构造过程必须允许被构造的对象有不同表示时。
====

角色
在这样的设计模式中，有以下几个角色：

* `Builder`：为创建一个产品对象的各个部件指定抽象接口。
* `ConcreteBuilder`：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。
* `Director`：构造一个使用Builder接口的对象，指导构建过程。
* `Product`：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。


=== 原型模式

====
定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
====

原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：

* 实现``Cloneable``接口。在java语言有一个``Cloneable``接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用``clone``方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出``CloneNotSupportedException``异常。
* 重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。

NOTE: 原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，他的原型类Prototype也常用抽象类来替代。